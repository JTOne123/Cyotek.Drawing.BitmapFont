/* AngelCode bitmap font parsing using C#
 * http://www.cyotek.com/blog/angelcode-bitmap-font-parsing-using-csharp
 *
 * Copyright © 2012-2015 Cyotek Ltd.
 *
 * Licensed under the MIT License. See license.txt for the full text.
 */

using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;

namespace Cyotek.Drawing.BitmapFont
{
  /// <summary>
  /// Parsing class for bitmap fonts generated by AngelCode BMFont
  /// </summary>
  public static class BitmapFontLoader
  {
    #region Static Methods

    /// <summary>
    /// Loads a bitmap font from a file, attempting to auto detect the file type
    /// </summary>
    /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
    /// <exception cref="FileNotFoundException">Thrown when the requested file is not present.</exception>
    /// <exception cref="InvalidDataException">Thrown when an Invalid Data error condition occurs.</exception>
    /// <param name="fileName">Name of the file to load.</param>
    /// <returns>
    /// A <see cref="BitmapFont"/> containing the loaded data.
    /// </returns>
    public static BitmapFont LoadFontFromFile(string fileName)
    {
      BitmapFont result;

      if (string.IsNullOrEmpty(fileName))
      {
        throw new ArgumentNullException("fileName", "File name not specified");
      }

      if (!File.Exists(fileName))
      {
        throw new FileNotFoundException(string.Format("Cannot find file '{0}'", fileName), fileName);
      }

      using (FileStream file = File.OpenRead(fileName))
      {
        using (TextReader reader = new StreamReader(file))
        {
          string line;

          line = reader.ReadLine();

          if (line.StartsWith("info "))
          {
            result = LoadFontFromTextFile(fileName);
          }
          else if (line.StartsWith("<?xml"))
          {
            result = LoadFontFromXmlFile(fileName);
          }
          else
          {
            throw new InvalidDataException("Unknown file format.");
          }
        }
      }

      return result;
    }

    /// <summary>
    /// Loads a bitmap font from a file containing font data in text format.
    /// </summary>
    /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
    /// <exception cref="FileNotFoundException">Thrown when the requested file is not present.</exception>
    /// <param name="fileName">Name of the file to load.</param>
    /// <returns>
    /// A <see cref="BitmapFont"/> containing the loaded data.
    /// </returns>
    public static BitmapFont LoadFontFromTextFile(string fileName)
    {
      BitmapFont font;

      if (string.IsNullOrEmpty(fileName))
      {
        throw new ArgumentNullException("fileName");
      }

      if (!File.Exists(fileName))
      {
        throw new FileNotFoundException(string.Format("Cannot find file '{0}'", fileName), fileName);
      }

      font = new BitmapFont();

      using (Stream stream = File.OpenRead(fileName))
      {
        font.LoadText(stream);
      }

      QualifyResourcePaths(font, Path.GetDirectoryName(fileName));

      return font;
    }

    /// <summary>
    /// Loads a bitmap font from a file containing font data in XML format.
    /// </summary>
    /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
    /// <exception cref="FileNotFoundException">Thrown when the requested file is not present.</exception>
    /// <param name="fileName">Name of the file to load.</param>
    /// <returns>
    /// A <see cref="BitmapFont"/> containing the loaded data.
    /// </returns>
    public static BitmapFont LoadFontFromXmlFile(string fileName)
    {
      BitmapFont font;

      if (string.IsNullOrEmpty(fileName))
      {
        throw new ArgumentNullException("fileName");
      }

      if (!File.Exists(fileName))
      {
        throw new FileNotFoundException(string.Format("Cannot find file '{0}'", fileName), fileName);
      }

      font = new BitmapFont();

      using (Stream stream = File.OpenRead(fileName))
      {
        font.LoadXml(stream);
      }

      QualifyResourcePaths(font, Path.GetDirectoryName(fileName));

      return font;
    }

    /// <summary>
    /// Returns a boolean from an array of name/value pairs.
    /// </summary>
    /// <param name="parts">The array of parts.</param>
    /// <param name="name">The name of the value to return.</param>
    /// <param name="defaultValue">Default value(if the key doesnt exist or can't be parsed)</param>
    /// <returns></returns>
    internal static bool GetNamedBool(string[] parts, string name, bool defaultValue = false)
    {
      string s = GetNamedString(parts, name);

      bool result;
      int v;
      if (int.TryParse(s, out v))
      {
        result = v > 0;
      }
      else
      {
        result = defaultValue;
      }

      return result;
    }

    /// <summary>
    /// Returns an integer from an array of name/value pairs.
    /// </summary>
    /// <param name="parts">The array of parts.</param>
    /// <param name="name">The name of the value to return.</param>
    /// <param name="defaultValue">Default value(if the key doesnt exist or can't be parsed)</param>
    /// <returns></returns>
    internal static int GetNamedInt(string[] parts, string name, int defaultValue = 0)
    {
      string s = GetNamedString(parts, name);

      int result;
      if (!int.TryParse(s, out result))
      {
        result = defaultValue;
      }

      return result;
    }

    /// <summary>
    /// Returns a string from an array of name/value pairs.
    /// </summary>
    /// <param name="parts">The array of parts.</param>
    /// <param name="name">The name of the value to return.</param>
    /// <returns></returns>
    internal static string GetNamedString(string[] parts, string name)
    {
      string result;

      result = string.Empty;

      for (int i = 0; i < parts.Length; i++)
      {
        string part;
        int nameEndIndex;

        part = parts[i];
        nameEndIndex = part.IndexOf('=');

        if (nameEndIndex != -1)
        {
          string namePart;

          namePart = part.Substring(0, nameEndIndex);

          if (string.Equals(name, namePart, StringComparison.InvariantCultureIgnoreCase))
          {
            int length;
            string valuePart;

            valuePart = part.Substring(nameEndIndex + 1);
            length = valuePart.Length;

            if (length > 1 && valuePart[0] == '"' && valuePart[length - 1] == '"')
            {
              valuePart = valuePart.Substring(1, length - 2);
            }

            result = valuePart;
            break;
          }
        }
      }

      return result;
    }

    /// <summary>
    /// Creates a Padding object from a string representation
    /// </summary>
    /// <param name="s">The string.</param>
    /// <returns></returns>
    internal static Padding ParsePadding(string s)
    {
      int rStart;
      int bStart;
      int lStart;

      rStart = s.IndexOf(',');
      bStart = s.IndexOf(',', rStart + 1);
      lStart = s.IndexOf(',', bStart + 1);

      return new Padding
             {
               Left = int.Parse(s.Substring(lStart + 1)),
               Top = int.Parse(s.Substring(0, rStart)),
               Right = int.Parse(s.Substring(rStart + 1, bStart - rStart - 1)),
               Bottom = int.Parse(s.Substring(bStart + 1, lStart - bStart - 1))
             };
    }

    /// <summary>
    /// Creates a Point object from a string representation
    /// </summary>
    /// <param name="s">The string.</param>
    /// <returns></returns>
    internal static Point ParsePoint(string s)
    {
      int yStart;

      yStart = s.IndexOf(',');

      return new Point
             {
               X = int.Parse(s.Substring(0, yStart)),
               Y = int.Parse(s.Substring(yStart + 1))
             };
    }

    /// <summary>
    /// Updates <see cref="Page"/> data with a fully qualified path
    /// </summary>
    /// <param name="font">The <see cref="BitmapFont"/> to update.</param>
    /// <param name="resourcePath">The path where texture resources are located.</param>
    internal static void QualifyResourcePaths(BitmapFont font, string resourcePath)
    {
      Page[] pages;

      pages = font.Pages;

      for (int i = 0; i < pages.Length; i++)
      {
        Page page;

        page = pages[i];
        page.FileName = Path.Combine(resourcePath, page.FileName);
        pages[i] = page;
      }

      font.Pages = pages;
    }

    /// <summary>
    /// Splits the specified string using a given delimiter, ignoring any instances of the delimiter as part of a quoted string.
    /// </summary>
    /// <param name="s">The string to split.</param>
    /// <param name="buffer">The output buffer where split strings will be placed. Must be larged enough to handle the contents of <paramref name="s"/>.</param>
    /// <returns></returns>
    internal static void Split(string s, string[] buffer)
    {
      int index;
      int partStart;
      char delimiter;

      delimiter = ' ';
      partStart = -1;
      index = 0;

      do
      {
        int partEnd;
        int quoteStart;
        int quoteEnd;
        int length;
        bool hasQuotes;

        quoteStart = s.IndexOf('"', partStart + 1);
        quoteEnd = s.IndexOf('"', quoteStart + 1);
        partEnd = s.IndexOf(delimiter, partStart + 1);

        if (partEnd == -1)
        {
          partEnd = s.Length;
        }

        hasQuotes = quoteStart != -1 && partEnd > quoteStart && partEnd < quoteEnd;
        if (hasQuotes)
        {
          partEnd = s.IndexOf(delimiter, quoteEnd + 1);
        }

        length = partEnd - partStart - 1;
        if (length > 0)
        {
          buffer[index] = s.Substring(partStart + 1, length);
          index++;
        }

        if (hasQuotes)
        {
          partStart = partEnd - 1;
        }

        partStart = s.IndexOf(delimiter, partStart + 1);
      } while (partStart != -1);
    }

    /// <summary>
    /// Converts the given collection into an array
    /// </summary>
    /// <typeparam name="T">Type of the items in the array</typeparam>
    /// <param name="values">The values.</param>
    /// <returns></returns>
    internal static T[] ToArray<T>(ICollection<T> values)
    {
      T[] result;

      // avoid a forced .NET 3 dependency just for one call to Linq

      result = new T[values.Count];
      values.CopyTo(result, 0);

      return result;
    }

    #endregion
  }
}
